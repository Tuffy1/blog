---
title: 基本包装类型
date: 2019-08-08 21:54:43
tags:
---
疑问：基本数据类型number/string/boolean的数值是直接保存在栈内存中，它们并不是对象，可是却相应地有自己的一些方法？

```js
var num = '123.321';
num.toFixed(2);

var str = 'string';
str.slice(2);

```

## 一 基本包装对象

作为一种基本类型的数据，在我们直观地调用相关方法时，后台已经自行为我们做了相应的处理，比如上面的str.slice(2)：

1. 创建一个String对象实例，传参为对应字符串的数值；
2. 执行指定的方法；
3. 销毁这个实例；

```js
var str = new String('string');
str.slice(2);
str = null;
```

即为了可以直接使用对应的方法，会在执行方法时的这一行代码处创建一个临时的实例，执行完毕后销毁这个实例。这与引用类型是不同的，引用类型的new操作符创建的实例会一直保存在内存中，直到执行流离开当前作用域，而包装对象只存在一行代码，用完即销毁，下次使用再重新创建销毁。故包装对象只能使用自带的属性和方法，而不能自行添加使用，这也是我们不能去修改基本类型数据的原因。

## 二 隐式转换：valueOf和toString方法

!['prototype.png'](/images/prototype.jpg)
Number/String/Boolean对象原型上都有各自的属性和方法，但它们都有相同的两个方法：valueOf()和toString()。
valueOf方法：可以得到包装对象实例的原始值

```js
var num = new Number(123); // num: Number{123}
typeof num === "Object"; // true
valueNum = num.valueOf(); // valueNum: 123
typeof valueNum === "number"; // true

var str = new String('');
str.valueOf(); //''
var obj = new Object({ name: 'tuffy' });
obj.valueOf(); // {name:'tuffy'}
var date = new Date();
date.valueOf(); // '1565248797100'
var arr = new Array(1, 2, 3);
arr.valueOf(); // [1, 2, 3]
```

除了Date转为了毫秒数，其他都转成了原始值
toString方法：返回字符串

```js
var num = 123;
num.toString(); // '123'
var str = '123';
str.toString(); // '123'
var bool = true;
bool.toString(); // 'true'
// object
var fun = function() {};
fun.toString(); // 'function() {}'
var arr = [1, 2, 3];
arr.toString(); // '1, 2, 3'
var date = new Date();
date.toString(); // 'Thu Aug 08 2019 ...'
var obj = { name: 'tuffy', age: 20 };
obj.toString(); // [Object, Object]
```

这两个方法经常在不同类型的数据间运算时调用，隐式转换情况时。

## 三 构造函数与转型函数

构造函数和转型函数的所得值及其属性都是不同的

```js
var str1 = new String(123); // str1: String {123}
var str2 = String(123); // str2: '123'

typeof str1; // 'object'（是一个对象实例）
typeof str2; // 'string'(是一种基本类型数据)
```

## 四 存在的意义

值得注意的是：

```js
var bool1 = new Boolean(false)
bool1 && true; // true
var bool2 = bool1.valueOf();
bool2 && true; // false
```

bool1所得是一个对象，对象的布尔值都为true，故bool1 && true为true；而bool2所得为bool1的原始值（即：false），故bool2 && true为false。
现在我们不建议进行显示地包装对象的创建，但包装对象在支持我们直观地对基本类型数据方法的调用和一些运算的转换起了重要作用。
